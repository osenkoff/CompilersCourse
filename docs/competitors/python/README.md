# Различие Python и Pascal

## Синтаксис циклов, ветвлений, блоков кода

### Pascal
Cтрого структурированный язык:
- Блоки кода ограничены ключевыми словами `begin ... end`
- Циклы `for ... do`, `while ... do`, `repeat ... until`
- Ветвления через `if ... then ... else`. 
- Точки с запятой обязательны.

#### Пример: 

```
// Блоки
begin...end;

// Ветвления
if condition then
  statement
else
  statement;

// Циклы
for i := 1 to 10 do
while condition do

```

### Python

Блоки кода определяются отступами:
- Циклы `for variable in iterable:` и `while condition:`
- Ветвления `if condition: ... elif ... else:` 
- Точки с запятой не нужны.

#### Пример:

```
# Блоки - отступы
# Ветвления
if condition:
    statement
else:
    statement

# Циклы
for i in range(1, 11):
while condition:
```

## Способ объявления типов переменных и параметров

- Для того чтобы определить переменную, в **Python** достаточно присвоить ей значение нужного типа. Эта компактность и понятность записи позволяет легко использовать язык Python непрофессионалам и школьникам. Возможна аннотация типов, но она не обязательна.

    #### Пример:

    ```
    a = 5 
    b = 3.14 
    password = 'Python' 
    lst = [1,2,3] 
    ```

- В **PascalABC.NET** определение переменной тоже максимально компактно, но следует использовать ключевое слово var. Это лишь немного сложнее Python Тип переменной при этом выводится автоматически по типу присваиваемого значения. Параметры имеют указанный тип.

   #### Примеры:

   1. 
    ```
    var a := 0;
    var b := 3.14; 
    var password := 'PascalABC.NET'; 
    var lst := |1,2,3|; 
    ```

    2.
    ```
    var 
    x: integer;
    y: real;
    ```

##  Набор типов данных

### Pascal:
- Базовые: `integer`, `real`, `char`, `boolean`, `string`
- Структурированные: `array`, `record`, `set`, `file`
- Указатели

### Python:

- Базовые: `int`, `float`, `bool`, `str`, `None`
- Структурированные: `list`, `tuple`, `dict`, `set`
- Объекты

## Набор операторов: арифметических, логических, сравнения и других

### Python

- **Арифметические**: использует стандартные символы, например: `+`, `-`, `*`, `/`, `**`, `%`
- **Логические**: Использует ключевые слова `and`, `or`, `not`.
- **Операторы сравнения**: Использует стандартные символы: `==` (равенство), `!=` (не равенство), `<` (меньше), `>` (больше), `<=` (меньше или равно), `>=` (больше или равно).


### Pascal
- **Арифметические**: Также использует те же символы для базовых операций, но может иметь специфические операторы для работы с целыми числами (например, `div` для целочисленного деления и `mod` для остатка от деления), которые в *Python* реализуются через операторы `/` и `%` соответственно.
- **Логичесикие**: Использует ключевые слова `AND`, `OR`, `NOT`, а также символы `&&` (для AND), `||` (для OR) и `!` (для NOT) в некоторых диалектах.
- **Также использует символы**: `=`, `<>`, `<`, `>`, `<=`, `>=`. В зависимости от диалекта, могут применяться и другие символы.

## Описание пользовательских функций

### Pascal:
Объявления с явным указанием возвращаемого типа, параметров с типами, обязательное тело `begin-end`.

#### Пример:

```
function Add(a, b: integer): integer;
begin
  Add := a + b;
end;
```

### Python:
Ключевое слово `def`, параметры без обязательного указания типа, тело с отступами, возможно возвращение любого типа

#### Пример:

```
def add(a, b):
    return a + b
```

## Описание пользовательских структур

### Pascal:

- Записи `(record)`: В *Pascal* пользовательская структура определяется с помощью типа `record`. В таком типе явно перечисляются поля, каждое из которых имеет свой тип данных.
- Статическая типизация: Типы данных в *Pascal* объявляются статически, то есть до выполнения программы. Это делает код более строгим, но требует от программиста точного указания типов.

    #### Пример:
    ```
    TYPE
      TStudent = RECORD
        Name: STRING;
        Age: INTEGER;
        AverageMark: REAL;
      END;

    VAR
      Student1: TStudent;
    ```

### Python:

-  Классы и объекты: В *Python* пользовательские структуры создаются с помощью классов, которые являются шаблонами для создания объектов. Классы позволяют инкапсулировать данные (атрибуты) и методы (функции), которые работают с этими данными.
- Динамическая типизация: Python использует динамическую типизацию, при которой тип переменной определяется во время выполнения программы. Это обеспечивает большую гибкость и ускоряет разработку, но требует внимательности при работе с типами.

    #### Пример:
    ```
        class Student:
        def __init__(self, name, age, average_mark):
            self.name = name
            self.age = age
            self.average_mark = average_mark

    student1 = Student("Иван", 20, 4.5)
    ```

## Управление памятью

### Pascal:
- Ручное управление через `New()`/`Dispose()`: Программист может явно выделять память для данных с помощью таких процедур, как **`New`** (для динамических переменных). 
- Соответственно, программист должен сам освобождать память после её использования с помощью процедуры **`Dispose`** (или аналогичных). 

### Python:
- Автоматическая сборка мусора: Python использует автоматический сборщик мусора, который отслеживает объекты в памяти и удаляет те, на которые больше нет ссылок, освобождая их для повторного использования
- Счётчики ссылок: Также Python использует счётчики ссылок для объектов. Каждый раз, когда на объект ссылаются, счётчик увеличивается, а когда ссылка снимается — уменьшается. Если счётчик становится равным нулю, объект удаляется из памяти. 
- Контроль: Программист не имеет прямого контроля над выделением или освобождением памяти. Это упрощает разработку, но может снижать производительность в критически важных к ресурсам задачах по сравнению с языками, где управление памятью ручное. 

## Обработка ошибок

### Pascal:

Ручная проверка: В Pascal ошибки часто обрабатываются путем явной проверки условий с помощью оператора if-then-else, try-except в современных версиях, не во всех диалектах

#### Пример:
```
try
  // код
except
  on E: Exception do
    // обработка
end;
```

## Python:
Блоки try-except: Python использует конструкции try-except для управления неожиданными ситуациями во время выполнения программы

#### Пример:
```
try:
  result = numerator / denominator
except ZeroDivisionError:
  print('Ошибка: деление на ноль!')

```