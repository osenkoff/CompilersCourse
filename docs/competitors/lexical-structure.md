# Различие Pascal и Python в их лексической структуре

## Элементы структурного программирования
### Блоки кода: 
Основное различие в лексической структуре заключается в способе определения блоков кода: **Pascal** использует пары ключевых слов `begin` и `end`, в то время как **Python** опирается на отступы (пробелы и табуляции) для визуального определения структуры и границ блоков кода. Эта разница напрямую влияет на читабельность и компактность кода, делая Python более визуально привлекательным и упрощая его написание по сравнению с Pascal.
 
#### Pascal
-  Блоки кода: Блоки кода, такие как тело процедуры, функции или управляющих конструкций, явно обозначаются ключевыми словами `begin` и `end`.

-  Пример:

   ```
   program Example;
   var
     x: integer;
   begin
     x := 10;
     if x > 5 then
     begin
       writeln('x is greater than 5');
       x := x * 2;
     end;
   end.
   ```
- Особенности: 
    - Каждая строка в Pascal заканчивается точкой с запятой (за некоторыми исключениями), что является частью его лексической структуры.
  
    - Ключевые слова `begin` и `end` могут использоваться для создания вложенных блоков любой сложности.
  
    - Структура программы жестко определена: раздел объявлений, затем раздел операторов.

#### Python
- Блоки кода: В Python блоки кода определяются с помощью отступов (одного или нескольких пробелов, или табуляций). Нет необходимости использовать специальные ключевые слова или символы для обозначения конца блока. 

- Пример: 
  ```
  def example():
    x = 10
    if x > 5:
        print('x is greater than 5')
        x = x * 2
    return x
  ```

- Особенности:
    - Отступы являются обязательным и семантически значимыми.
  
    - Двоеточие `:` обозначает начало нового блока кода.
  
    - Нет необходимости в явных разделителях блоков или точках с запятой.

    - Структура программы свободная, без обязательных разделов.


### Ветвления

#### Pascal
- Для условных переходов используется оператор `if...then...else`, где `then` и `else` (если есть) отделяют код, выполняемый в зависимости от условия.

- Особенности:
    - Ключевое слово `then` обязательно после условия.
    - Отстутствие двоеточий после условий.
    - Составные операторы требуют обрамлениц `begin...end`.
    - Множественное ветвление требует вложенных if или case.
  
#### Python
- Ветвление реализуется с помощью оператора `if...else:` (или `elif`), который требует двоеточия после условия, а тело ветки указывается с помощью отступов.

- Особенности:
    - Двоеточие `:` обязательно после каждого условия.

    - Отступы определяют тело ветвления.

    - Ключевое слово `elif` для цепочек условий (вместо `else if`).

    - Любые выражения в условиях (не только булевы).

    - Тернарный оператор для компактной записи.

### Циклы

В лексической структуре циклов **Pascal** применяет строгие ключевые слова, знаки пунктуации и блоки `begin...end` с обязательными точками с запятой, что структурирует и формализует код. В **Python** структурный контроль достигается через двоеточия и обязательные отступы, что упрощает и делает код визуально более чистым, но требует внимательности к форматированию. Это принципиальное отличие отражает разные философии дизайна языков: Pascal с формальными лексическими маркерами против Python с визуально-ориентированным синтаксисом.

#### Pascal
- Основные циклические конструкции: `for...do`, `while...do`, `repeat...until`.

- Границы тела цикла обозначаются ключевыми словами `begin` и `end`, если в теле несколько операторов.

- Каждая инструкция заканчивается точкой с запятой.

- Примеры циклов:

  Цикл **for**:
  ```
  for i := 1 to 10 do
  begin
    writeln(i);
  end;
  ```

  Цикл **while**:
  ```
  while x < 10 do
  begin
    x := x + 1;
  end;
  ```

  Цикл **repeat**:
  ```
  repeat
    x := x + 1;
  until x >= 10;
  ```

Особенности лексики:
- `do` служит разделителем условия и тела цикла.

- Точка с запятой обязательна после каждого оператора (за исключением некоторых случаев, например, перед `until` в цикле `repeat` точка с запятой не ставится).

- Тело цикла может быть одним оператором без `begin...end`, но обычно для нескольких операторов требуется блок `begin...end`.

#### Python
- Основные циклы: `for` и `while`.

- Тело цикла начинается после двоеточия `:`.

- Используются отступы для определения границ блока.

- Примеры циклов:
   
  Цикл **for**:
  ```
  for i in range(1, 11):
    print(i)
  ```

  Цикл **while**:
  ```
  while x < 10:
    x += 1
  ```

Особенности лексики:

- Отступы обязательны и семантически значимы.

- Нет необходимости в явных завершающих символах или ключевых словах для конца тела цикла.

- Цикл `for` разбирается как перебор элементов последовательности или генератора, а не как счетчик с явным шагом, как в Pascal.

## Средства для ввода/вывода и другие встроенные функции

### Ввод/вывод в Pascal 
- Для вывода используется процедура `writeln` (печать строки с переходом на новую строку) и `write` (печать без перехода).

- Для ввода - процедура `readln` (считывание строки или значения с переходом на новую строку) и `read` (без перехода).

- Синтаксис явно процедурный, вызовы встроенных функций и процедур выполняются как инструкции с параметрами в скобках.

#### Примеры:
``` 
writeln('Enter your name:');
readln(name);
writeln('Hello, ', name);
```

- Особенности:

    - Аргументы передаются через запятую.

    - Каждая инструкция заканчивается точкой с запятой.

    - Нет встроенной поддержки форматирования в лексике, используется внешняя библиотека или стандартные процедуры.

### Ввод/вывод в Python
- Для вывода используется функция `print()`, встроенная и универсальная.

- Для ввода используется функция `input()`, возвращающая введённую строку.

- Синтаксис функциональный, вызовы функций с параметрами в скобках.

#### Примеры:
```
print('Enter your name:')
name = input()
print('Hello,', name)
```
- Особенности:
    - Разделение аргументов функцией `print` запятыми.

    - Нет необходимости ставить точки с запятой.

    - Функция `print` поддерживает множество параметров (например, разделитель, конец строки).

    - `input()` всегда возвращает строку, необходима явная конвертация при необходимости.

## Другие встроенные функции

### Pascal
- Основные встроенные функции:

    - Арифметические: `abs(x)`, `sqrt(x)`, `sin(x)`, `cos(x)`, `exp(x)`

    - Логические и сравнения: `odd(x)` (проверка нечётности), стандартные операторы

    - Преобразование: str(), val() для преобразования между строками и числами

- Синтаксис вызова функций — с круглыми скобками и аргументами через запятую.

#### Пример:
```
x := abs(-10);
s := '123';
val(s, n, code);
```

- Инструкции заканчиваются точкой с запятой.

### Python

- Широкий набор встроенных функций:

    - Арифметические: `abs()`, `pow()`, `round()`

    - Преобразование типов: `int()`, `str()`, `float()`

    - Работа с последовательностями: `len()`, `range()`, `enumerate()`

- Вызов функций через имена и круглые скобки, аргументы через запятую.

#### Пример:
```
x = abs(-10)
s = '123'
n = int(s)
```

- Нет необходимости в разделении команд точками с запятой.

## Встроенные типы данных для целых чисел, числе с плавающей точкой и строк

### Pascal

Требует явного объявления типов данных и переменных в начале программы или в разделах объявления. Синтаксис языка более строгий, с четко обозначенными операторами и структурами.

#### Целые числа:
- Типы: `integer`, `shortint`, `longint`, `byte`, `word` (зависит от реализации).

- Объявление переменных с указанием типа:
  ```
  var
  x: integer;
  y: byte;
  ```

- Целые числа записываются как последовательность цифр без кавычек.

- Лексика: литералы целых чисел — цифры, возможно с знаком `+` или `-`.

- Пример использования:
  ```
  x := 42;
  y := -15;
  ```

#### Числа с плавающей точкой
- Основной тип - `real`.
  
- В некоторых реализациях есть `string`, `double` для разной точности.
  
- Лексика: числа с десятичной точкой, иногда с экспонентой e или E.

- Пример:
  ```
  var
    pi: real;
  begin
    pi := 3.14159;
  end;
  ```

#### Строки
- Тип `string` — последовательность символов фиксированной или переменной длины (зависит от версии компилятора).

- Строковые литералы заключаются в одинарные кавычки `'...'`.

- Пример:
  ```
  text
  var
    s: string;
  begin
    s := 'Hello, world!';
  end; 
  ```

- В лексике строка — последовательность символов в одинарных кавычках.

### Python

#### Целые числа

- Тип `int` — целые числа произвольной длины.

- Записываются как последовательность цифр, без необходимости объявления типа.

- Лексика: целочисленные литералы без кавычек, поддерживаются десятичные, шестнадцатеричные (`0x`), восьмеричные (`0o`), двоичные (`0b`).

- Примеры:
  ```
  x = 42
  y = -15
  z = 0xFF
  ```

#### Числа с плавающей точкой
- Тип `float`.

- Лексика: число с десятичной точкой и/или экспонентой `e`/`E`.

- Пример:

  ```
  pi = 3.14159
  avogadro = 6.022e23
  ```

#### Строки
- Тип `str` — последовательность символов `Unicode`.

- Строковые литералы могут быть в одинарных `'...'` или двойных кавычках `"..."`.

- Поддерживаются многострочные строки с тройными кавычками `'''...'''` или `"""..."""`.

- Пример:

  ```
  s = 'Hello, world!'
  text = "Python"
  multiline = '''Line 1
  Line 2'''
  ```

## Выражения с операторами

### Арифметические операторы

### Pascal
- Бинарные опираторы: `+`(сложение), `-`(вычитание), `*`(умножение), `/`(деление вещественного результата).
  
- Целочисленное деление и остаток от деления: `DIV`(целочисленное деление), `MOD` (остаток от деления).
  
- Унарный оператор минус знак `-` для изменения знака числа.

- Приоритеты операций: сначала скобки, затем унарный минус, умножение и деление, затем сложение и вычитание.

- Строгая типизация: операции над совместимыми типами, результат деления `/` всегда вещественен.

- Пример:

  ```
  var
    a, b, c, y, z: integer;
    x, r: real;
  begin
    a := 10 + 5;
    b := 10 - 5;
    c := 10 * 5;

    x := 10 / 3;   //вещественное деление: 3.333...
    y := 10 div 3; //целочисленное деление: 3
    z := 10 mod 3; //остаток от деления: 1

    x := -5; //унарный минус
    y := +x; //унарный плюс

    r := Power(2, 3) //возведение в степень: 8.0
    r := Sqrt(16)    //квадратный корень: 4.0
  end.

### Python
- Бинарные операторы: `+`, `-`, `*`, `/`(обычное деление, результат всегда с плавающей запятой).

- Целочисленное деление: `//` - результат деления (целая часть).

- Остаток от деления `%`.

- Возведение в степень: `**`.

- Унарный минус: `-`.

- Нет отдельных операторов для целочисленного деления и остатка, используются символы

- Допускаются смешанные типы (int и float), арифметика с плавающей точкой применяется автоматически.

- Примеры:

  ```
  a = 10 + 5     # Сложение: 15
  b = 10 - 5     # Вычитание: 5
  c = 10 * 5     # Умножение: 50

  x = 10 / 3     # Вещественное деление: 3.333...
  c = 10 // 3    # Целочисленное деление: 3
  b = 10 % 3     # Остаток от деления: 1

  p = 2 ** 3     # Степень: 8

  x = -5         # Унарный минус
  y = +x         # Унарный плюс
  ```

Основные различия лексики:
-------------------------

| Характеристика        |                         Pascal                          |                                                      Python |
| --------------------- | :-----------------------------------------------------: | ----------------------------------------------------------: |
| Сложение              |                           `+`                           |                                                         `+` |
| Вычитание             |                           `-`                           |                                                         `-` |
| Умножение             |                           `*`                           |                                            `*`Ячейка 2.3`*` |
| Деление               |                    `/`(вещественное)                    |                                           `/`(вещественное) |
| Целочисленное деление |                  `DIV`(ключевое слово)                  |                                              `//`(оператор) |
| Остаток от деления    |                  `MOD`(ключевое слово)                  |                                              `%`(опертатор) |
| Возведение в степень  |                     Функция `Power`                     |                                              `**`(оператор) |
| Унарный минус         |                           `-`                           |                                                         `-` |
| Типизация арифметики  |              Строгая, требует соответствия              |         Автоматическое совместное использование int и float |
| Приоритеты операций   | Скобки, унарный минус, `*`, `/`, `DIV`, `MOD`, `+`, `-` | Скобки, унарный минус, `**`, `*`, `/`, `//`, ` %`, `+`, `-` |


### Логические операторы

### Pascal
- Бинарные операции: `and`(логическое И), `or`(логическое ИЛИ), `xor`(исключающее ИЛИ) — работают с операндами типа логического и возвращают булевское значение.

- Унарный оператор: `not`(логическое отрицание).

- Операции отношения (сравнения): `=`, `<>`(не равно), `<`, `>`, `<=`, `>=`, которые используются в логических выражениях.

- Важно отметить режим расчета по сокращенной схеме, `and` и `or`: если результат может быть известен по первому операнду, второй не сохраняется.

- Приоритеты операций: операции `and` и `or` имеют более высокий приоритет, чем операции сравнения, поэтому для более четкого выражения рекомендуется использовать скобки.

- Логические выражения широко применяются в конструкциях управления: `if`, `while`, `repeat-until`.

- Примеры:
  1.
  ```
  var
    a, b, c: boolean;
  begin
    a := True;
    b := False;

    c := a and b; //логическое И: False
    c := a or b;  //логическое ИЛИ: True
    c := not a;   //Логическое НЕ: False

    c := a xor b; //исключающее ИЛИ: True

    c := (a and b) or (not a); //комбинированные выражения 
  end.
  ```

  2.
  ```
  var
    x, y: integer;
    flag: boolean;
  begin
    x := 5;
    y := 10;
  
    { Корректные выражения }
    flag := (x > 0) and (y < 20);    // True
    flag := not (x = y);             // True
    flag := (x > 0) xor (y > 0);     // False (оба True)
  
    { Ошибки компиляции }
    { flag := x and y; }             // Ошибка: integer не boolean
    { flag := not x; }               // Ошибка: integer не boolean
  end.
  ```


### Python

- Бинарные операции: `and`, `or`. 
  `xor` - отсутствует как ключевое слово, реализуется через:
    - Оператор `!=` для булевых значений.
    - Побитовый операторо `^` для булевых значений.
    - Функцию `operator.xor()`.
    - Комбинацию `(a and not b) or (not a and b)`.

- Унарный оператор: `not`.

- Операция сравнение: `==`, `!=`, `<`, `>`, `<=`, `>=` — эти операции могут объединяться в цепочки сравнений (например, `a < b < c`).

- В Python операторы `and` и `or` используют короткое замыкание — второй операнд вычисляется только при необходимости.

- Приоритеты логических операций намного ниже, чем у сравнений, что позволяет писать выражения с каскадными сравнениями без лишних скобок.

- Эти операторы часто используются в условных и циклических конструкциях.

- Примеры:
  1.
  ```
  # Базовые логические операции
  a = True
  b = False

  c = a and b     # Логическое И: False
  c = a or b      # Логическое ИЛИ: True  
  c = not a       # Логическое НЕ: False

  # Комбинированные выражения
  c = (a and b) or (not a)
  ```

  2.
  ```
  # Реализация XOR:
  # Способ 1: через оператор != (для булевых значений)
  a = True
  b = False
  result = a != b          # True XOR False = True

  # Способ 2: через побитовый оператор ^ (для булевых значений)
  result = a ^ b           # True XOR False = True

  # Способ 3: через модуль operator
  import operator
  result = operator.xor(a, b)  # True XOR False = True

  # Способ 4: через комбинацию and/or
  result = (a and not b) or (not a and b)  # True
  ```

### Операторы сравнения

### Pascal

- Операторы сравнения на равенство: `=`, `<>`.

- Операторы сравнения на порядок: `<`, `>`, `<=`, `>=`.

- Специальные операторы для множеств: `in`(проверка элементов поставки), `<=`(проверка подмножества), `>=`(проверка надмножества).

- Операнды должны быть совместимых типов — стандартные типы(integer, real, char, boolean), строки, указатели, множества.

- Результат всегда логического типа `BOOLEAN`.

- Приоритеты: операции сравнения имеют меньший приоритет по сравнению с арифметическими, но выше по сравнению с логическими операторами.

### Python

- Основные операторы: `==`, `!=`, `<`, `>`, `<=`, `>=`.

- Дополнительное отличие: поддержка цепочек сравнений (например, `a < b < c`), что упрощает запись сложных выражений.

- Сравнение возможно между совместимыми по типам объектов (в Python 3 сравнение несовместимых типов (например, числа и строки) вызывает TypeError).

- Результат — булево значение `True` или `False`.

- Приоритет одинаков для всех операторов сравнения, ниже, чем арифметические, но выше, чем логические операторы.

## Пользовательские составные типы данных:
### Массивы

### Pascal
Массив - структура данных, содержащая фиксированное количество элементов одного типа.

Объявление массивов:
```
{ Одномерный массив }
var 
  a: array[1..10] of integer;          // 10 элементов, индексы 1..10
  b: array[-5..5] of real;             // 11 элементов, индексы -5..5
  c: array['a'..'z'] of boolean;       // 26 элементов, индексы 'a'..'z'


{ Многомерный массив }
var
  matrix: array[1..3, 1..5] of real;     // 3×5 матрица
  cube: array[1..2, 1..3, 1..4] of char; // 2×3×4 трёхмерный массив
```

Особенности:
 - Гибкая индексация: индексы могут начинаться не обязательно с 0 или 1, диапазон задается явно.
 - Фиксированный размер: размер массива определяется на этапе компиляции.
 - Однотипность: элементы типа, закрепленные в объявлении, имеют один общий тип.
 - Образение к элементам происходит через имя массива и индекс в квадратных скобках.

Пример работы с массивами:

```
program ArrayExample;
var
  arr: array[1..5] of integer;
  i, sum: integer;
begin
  { Инициализация массива }
  for i := 1 to 5 do
    arr[i] := i * 10;
  
  { Обращение к элементам }
  arr[1] := 100;
  arr[3] := arr[2] + 50;
  
  { Вывод элементов }
  for i := 1 to 5 do
    write(arr[i], ' ');  // 100 20 70 40 50
  
  { Работа с многомерным массивом }
  var matrix: array[1..2, 1..3] of integer;
  for i := 1 to 2 do
    for j := 1 to 3 do
      matrix[i, j] := i * j;
end.
```

### Python
В Python основным типом для работы с коллекциями является list(список), который используется как динамический массив.

Объявление и создание массивов:
```
# Базовые списки (динамические массивы)
a = [1, 2, 3, 4, 5]                    # Список целых чисел
b = ['apple', 'banana', 'cherry']      # Список строк
c = [1, 'hello', 3.14, True]           # Список с разными типами данных
d = []                                 # Пустой список
e = list(range(1, 6))                  # [1, 2, 3, 4, 5]
```

Особенности:
 - Динамический массив: Размер массива(списка) может изменяться во время выполнения.
 - Гибкая типизация: Элементы списка могут быть разного типа, не обязательно однотипные.
 - Индексация с 0: первый элемент имеет индекс 0.
 - Отрицательные индексы: Доступ с конца списка (-1 -  последний элемент).

Пример работы с массивами:
```
# Создание массива чисел
numbers = [10, 20, 30, 40, 50]

print("Исходный массив:", numbers)
print("Первый элемент:", numbers[0])      # 10
print("Последний элемент:", numbers[-1])  # 50

# Добавление элементов
numbers.append(60)           # Добавить в конец
numbers.insert(2, 25)        # Вставить на позицию 2
print("После добавления элементов:", numbers)  # [10, 20, 25, 30, 40, 50, 60]

# Удаление элементов
numbers.pop()                # Удалить последний
numbers.remove(25)           # Удалить элемент 25
print("После удаления элементов:", numbers)    # [10, 20, 30, 40, 50]

# Изменение элементов
numbers[1] = 99
print("После изменения второго элемента:", numbers)  # [10, 99, 30, 40, 50]

# Срезы (slices)
print("Первые три элемента:", numbers[:3])    # [10, 99, 30]
print("Элементы с 2 по 4:", numbers[1:4])     # [99, 30, 40]
print("Каждый второй элемент:", numbers[::2]) # [10, 30, 50]

# Поиск и проверка
print("Индекс элемента 40:", numbers.index(40))  # 3
print("Есть ли 100 в массиве?", 100 in numbers)  # False

# Сумма и длина
print("Сумма элементов:", sum(numbers))      # 229
print("Длина массива:", len(numbers))        # 5

# Итерация по массиву
print("Элементы массива:")
for i, number in enumerate(numbers):
    print(f"  numbers[{i}] = {number}")
```

### Структуры (записи)

### Pascal

- В Pascal структуры реализуются через тип `record`.

- Объявление записей включает в себя перечисление названных полей с их типами:
  ```
  type TPerson = record
    Name: string;
    Age: integer;
  end;
  ```

- Поля доступа осуществляются через точку: `person.Name`, `person.Age`.

- Запись — статический тип с фиксированной структурой и строго типизированными полями.

- Записи предназначены для группировки разнотипных данных в одну логическую единицу.

- Возможна вложенность записей, рекурсивные структуры (с помощью указателей).

- Пример работы:
```
var
  person1, person2: TPerson;
  employee: TEmployee;

begin
  { Инициализация полей }
  person1.Name := 'Иван Петров';
  person1.Age := 25;
  person1.Height := 180.5;
  person1.IsStudent := false;

  { Копирование записей }
  person2 := person1;
  person2.Name := 'Мария Сидорова';

  { Работа с вложенными записями }
  employee.Person.Name := 'Алексей Иванов';
  employee.Address.City := 'Москва';
  employee.Salary := 50000.0;

  { Массив записей }
  var people: array[1..10] of TPerson;
  people[1] := person1;
  people[2] := person2;
end;
```

### Python

- Аналогичные записи в Python -  словарь `dict` или классы объекстов.

- Для простых случаев структурированные данные часто сохраняются в словарях с ключами - строками:

Словари (dict) - гибкий подход:
```
# Простое создание структуры
person = {'Name': 'Ivan', 'Age': 30, 'City': 'Moscow'}

# Доступ к полям
print(person['Name'])  # Ivan
print(person.get('Age'))  # 30

# Динамическое добавление полей
person['Salary'] = 50000
person['IsStudent'] = False

# Изменение структуры во время выполнения
del person['City']
person['Location'] = 'SPb'

print(person)  # {'Name': 'Ivan', 'Age': 30, 'Salary': 50000, 'IsStudent': False, 'Location': 'SPb'}
```

- Доступ к полям происходит по ключу: `person['Name']`, `person[Age]`.

- Для строготипизированных структур используется модуль `collections.namedtuple` или классы с атрибутами.

- Классы позволяют определять, например, поля как атрибуты объекта:

```
class Person:
    def __init__(self, name, age, city=None):
        self.Name = name
        self.Age = age
        self.City = city
        # Динамическое добавление атрибутов возможно
        self.created_at = '2024-01-01'
    
    def display_info(self):
        return f"{self.Name}, {self.Age} years, from {self.City}"

# Создание объектов
person1 = Person('Ivan', 30, 'Moscow')
person2 = Person('Maria', 25)

# Доступ к полям
print(person1.Name)  # Ivan
print(person1.display_info())  # Ivan, 30 years, from Moscow

# Динамическое изменение структуры
person1.Salary = 50000  # Новое поле
person1.Age = 31        # Изменение существующего поля
```

- Python активируется типизированным, структура может изменяться во время выполнения (добавляться поля).