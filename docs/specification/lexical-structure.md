# Лексическая структура языка C#

## 1. Примеры кода
```
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("Hello, world!");
    }
}
```

## 2. Ключевые слова

C# включает ключевые слова, которые являются зарезервированными идентификаторами в любой части программы C#.

|    Слово      | Предназначение |
| --------------| ---------------|
| `abstract`    | Объявление абстрактных классов и абстрактных членов класса(методов, свойств) |
| `as`          | Преобразует результат выражения в указанный ссылочный или поддерживающий значения NULL тип |
| `base`        | Используется для доступа к членам базового класса их производного класса |
| `bool`        | Логический тип данных |
| `break`       | Прерывание цикла или switch |
| `byte`        | 8 - битный целочисленный тип |
| `case`        | Метка в switch |
| `catch`       | Обработка исключений |
| `char`        | Символьный тип |
| `checked`     | Проверка переполнения для арифметических операций |
| `class`       | Объявление класса |
| `const`       | Используется для объявления постоянного поля или локальной константы |
| `continue`    | Продолжение следующей итерации цикла |
| `decimal`     | Десятичный тип с плавающей запятой |
| `default`     | Значение по умолчанию |
| `delegate`    | Ссылочный тип, который позволяет хранить ссылку на метод с определенной сигнатурой (типом возвращаемого значени и параметрами) |
| `do`          | Выполняет оператор или блок операторов, пока указанное логическое выражение вычисляется в true |
| `double`      | Числовой тип с плавающей точкой двойной точности |
| `else`        | Альтернативная ветка `if`|
| `enum`        | Тип перечисления |
| `event`       | Событие (это элемент, позволяющий объекту активировать уведомления) |
| `explicit`    | Оператор явного преобразования типа |
| `extern`      | Используется для объявления метода с внешней  |
| `false`       | Логическое значение "ложь" |
| `finally`     | Исключения в асинхронных и итераторах |
| `fixed`       | Фиксированная инструкция — закрепление переменной для операций указателя |
| `float`       | Тип с плавающей точкой одинарной точности |
| `for`         | Выполняет оператор или блок операторов, пока указанное логическое выражение вычисляется в true |
| `foreach`     | Цикл перебора коллекции |
| `goto`        | Безусловный переход, который передает управление программе к указанной метке в пределах того же метода |
| `if`          | Условный оператор |
| `implicit`    | Используется для определения неявного оператора преобразования типов, который позволяет автоматически преобразовывать один тип данных в другой, без явного указания оператора приведения типов |
| `in`          | Модификатор параметра, передающий аргумент методу по ссылке, но запрещающий его изменение внутри метода для повышения производительности при работе с большими структурами, и как модификатор универсального типа в универсальных интерфейсах и делегатах, указывающий на контравариантность типа |
| `int`         | Целочисленные числовые типы - 32 бит |
| `interface`   | Определение интерфейса,используется для определения контракта, который описывает набор методов, свойств, событий и индексаторов, которые класс или структура должны предоставить |
| `internal`    | Модификатор доступа для типов и членов типов |
| `is`          | Проверяет, совместим ли результат выражения с заданным типом |
| `lock`        | Используется для создания критической секции — блока кода, к которому одновременно может получить доступ только один поток, обеспечивая потокобезопасность при работе с общими ресурсами |
| `long`        | 64-битное целое число |
| `namespace`   | Используется для объявления области действия, которая содержит набор связанных объектов |
| `new`         | Используется в качестве: нового оператора, нового модификатора, нового ограничения |
| `null`        | Литерал, представляющий пустую ссылку, которая не ссылается на какой-либо объект |
| `object`      | Базовым типом для всех других типов, включая как ссылочные, так и типы значений. Он позволяет переменным хранить значение любого типа данных, выступая в качестве универсальной ссылки |
| `operator`    | Определение и перегрузка операторов к классах и структурах |
| `out`         | Используется: 1. В качестве модификатора параметров, который позволяет передавать аргумент методу по ссылке, а не по значению. 2. В объявлениях параметров универсального типа для интерфейсов и делегатов, указывающих, что параметр типа является ковариантным|
| `override`    |  Модификатор требуется для расширения или изменения абстрактной или виртуальной реализации унаследованного метода, свойства, индексатора или события |
| `params`      | Позволяет методу принимать переменное количество аргументов одного типа |
| `private`     | Модификатор доступа члена \ (означает, что члены класса (поля, методы, свойства и т.д.) или структуры доступны только внутри того же класса или структуры, где они объявлены) |
| `protected`   | Модификатор доступа члена (предоставляет доступ к члену класса (полю или методу) как из самого класса, так и из любых производных (наследуемых) классов, независимо от их местонахождения в других сборках) |
| `public`      | Модификатор доступа для типов и элементов типов (указывает, что элемент (тип, член класса или метода) доступен без ограничений, то есть из любой части программы и из любой сборки) |
| `readonly`    | Для полей, чье значение может быть присвоено только в месте объявления или в конструкторе класса, а после этого изменяться не может |
| `ref`         | Передача аргумента в методе по ссылке |
| `return`      | Завершает выполнение функции, в которой она отображается, и возвращает элемент управления и результат функции, если таковой есть, вызывающему объекту |
| `sbyte`       | Целочисленный тип 8 бит со знаком|
| `sealed`      | Запрет наследования или переопределения |
| `short`       | Целочисленный тип 16 бит |
| `sizeof`      | Оператор определения потребностей памяти для заданного типа |
| `stackalloc`  | Выделяет блок памяти в стеке |
| `static`      | Модификатор для объявления статического элемента |
| `string`      | Строковый тип |
| `struct`      | Тип структуры |
| `switch`      | Множественное ветвление | 
| `this`        | Относится к текущему экземпляру класса и также используется в качестве модификатора первого параметра метода расширения |
| `throw`       | Генерация исключения |
| `true`        | Логическое значение "истина" |
| `try`         | Блок обработки исключений |
| `typeof`      | Получает экземпляр для указанного типа |
| `uint`        | Беззнаковый целочисленный тип 32 бита |
| `ulong`       | 	Беззнаковый целочисленный тип 64 бита |
| `unchecked`   | Отключение проверки переполнения |
| `unsafe`      | Небезопасный контекст, который требуется для любой операции с указателями |
| `using`       | Определяет область, в конце которой удаляется объект |
| `virtual`     | Используется для изменения объявлений методов, свойств, индексаторов и событий и разрешения их переопределения в производном классе |
| `void`        | Используется в качестве возвращаемого типа метода (или локальной функции), чтобы указать, что метод не возвращает значение |
| `volatile`    | Указывает, что поле может быть изменено несколькими потоками, выполняющимися одновременно |
| `while`       | Выполняет оператор или блок операторов, пока указанное логическое выражение вычисляется в true (Цикл while)|

## Контекстные ключевые слова:
`add`, `allows`, `alias`, `and`, `ascending`, `args`, `async`, `await`, `by`, `descending`, `dynamic`, `equals`, `extension`, `field`, `file`, `from`, `get`, `global`, `group`, `init`, `into`, 
`join`, `let`, `managed (соглашение о вызове указателя функции)`, `nameof`, `nint`, `not`,
`notnull`, `nuint`, `on`, `or`, `orderby`, `partial (тип)`, `partial (член)`, `record`,  `remove`, `required`, `scoped`, `select`, `set`, `unmanaged (соглашение о вызове указателя функции)`, `unmanaged (ограничение универсального типа)`, `value`, `var`, `when (условие фильтра)`, `where (ограничение универсального типа)`, `where (условие запроса)`, `with`, `yield`

## 3. Идентификаторы

Идентификатор — это имя, которое вы назначаете типу (классу, интерфейсу, структуре, делегату или перечислению), члену, переменной или пространству имен.

### Правила именования 
Компилятор C# выдает ошибку для любого идентификатора, который не соответствует этим правилам:
- Идентификаторы должны начинаться с буквы или подчеркивания (_).
- Идентификаторы могут содержать буквенные символы Юникода, десятичные цифры, соединительные символы Юникода, комбинируемые символы Юникода или символы форматирования Юникода.
- Не могут совпадать с зарезервированными ключевыми словами.
- Регистрозависимые (myVar и myvar - разные идентификаторы)

Можно объявить идентификаторы, соответствующие ключевым словам C#, с помощью префикса @ идентификатора. @ не является частью имени идентификатора. Например, @if объявляет идентификатор с именем if. Эти дословные идентификаторы в основном предназначены для взаимодействия с идентификаторами, объявленными другими языками.

**Примеры допустимых идентификаторов:**
---
```
myVariable
_customer
item2
MyClass
```

**Примеры недопустимых идентификаторов:**
---
```
2item      // начинается с цифры
my-var     // содержит дефис
class      // ключевое слово
```

## 4. Литералы

Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. Литералы бывают логическими, целочисленными, вещественными, символьными и строчными. И отдельный литерал представляет ключевое слово **null**.

### 4.1. Литералы чисел

Целочисленные литералы начинаются с цифры и не имеют дробных частей или экспонент. Целочисленные литералы можно указать в десятичной, двоичной, восьмеричной или шестнадцатеричной форме. При необходимости можно указать целый литерал без знака, а также длинный или длинный тип с помощью суффикса.

Чтобы указать десятичный целочисленный литерал, начинайте спецификацию с любой цифры, кроме нуля.
Например:
```
int i = 157;        // Десятичный литерал
int j = 0198;       // Не десятичное число; ошибочный восьмеричный литерал
int k = 0365;       // Начальный ноль указывает восьмеричный литерал, а не десятичный
int m = 36'000'000  // Разделители цифр делают большие значения более удобочитаемыми
```

Чтобы указать восьмеричный целочисленный литерал, начинайте спецификацию с нуля, за которым следует ряд цифр в диапазоне от 0 до 7. Цифры 8 и 9 при указании восьмеричного литерала будут ошибками.
Например:
```
int i = 0377;   // Восьмеричный литерал
int j = 0397;   // Ошибка: 9 не является восьмеричной цифрой
```

Чтобы указать шестнадцатеричный целочисленный литерал, начните спецификацию с `0x` или (в случае "x" не имеет значения), за которой следует последовательность цифр в диапазоне `0X` и `09` (или) через `a` (или `A``f``F` ). Шестнадцатеричные цифры от `a` (или `A`) до `f` (или `F`) представляют собой значения в диапазоне от 10 до 15. 
Например:
```
int i = 0x3fff;   // Шестнадцатеричный литерал
int j = 0X3FFF;   // Равно i
```

Чтобы указать неподписанный тип, используйте `u` или `U` суффикс. Чтобы указать длинный тип, используйте `l` либо суффикс `L` . Для указания 64-разрядного целочисленного типа используется суффикс `LL` или `ll`. 
Например:
```
unsigned val_1 = 328u;  //Значение без знака
long val_2 = 0x7FFFFFL; // Длинное значение, указанное в виде шестнадцатеричного литерала
unsigned long val_3 = 0776745ul; // Длинное значение без знака
auto val_4 = 108LL;  // signed long long
auto val_4 = 0x8000000000000000ULL << 16;  // unsigned long long
```

Разделители цифр: вы можете использовать символ с одним кавычками (apostrophe) для разделения значений в больших числах, чтобы упростить чтение для людей. Разделители не влияют на компиляцию.
Пример:
```
long long i = 24'847'458'121;
```

### 4.2. Литералы строк

**Строковый литерал** — это последовательность символов из исходного набора символов, заключенного в двойные кавычки (`" "`). Строковые литералы используются для представления последовательности символов, которые объединяются в виде строки, завершаемой значением NULL. С буквой `L` всегда необходимо префиксить строковые литералы.

Строковые литералы представляют строки. Строки заключаются в двойные кавычки:
```
Console.WriteLine("hello");
Console.WriteLine("фыва");
Console.WriteLine("hello word");
```

Если внутри строки необходимо вывести двойную кавычку, то такая внутренняя кавычка предваряется обратным слешем:
```
Console.WriteLine("Компания \"Рога и копыта\"");
```

Также в строках можно использовать управляющие последовательности. Например, последовательность '\n' осуществляет перевод на новую строку:
```
Console.WriteLine("Привет \nмир");
```

При выводе на консоль слово "мир" будет перенесено на новую строку:
```
Привет
мир
```

## 5. Операторы

**Операторы** — это символы, которые используются для выполнения операций с операндами. Операндами могут быть переменные и/или константы.

Например, в выражении `2 + 3`, `+` — это оператор, который используется для выполнения операции сложения, а `2` и `3` — операнды.

Операторы используются для управления переменными и их значениями в программе. C# поддерживает ряд операторов, разделенных по типам выполняемых ими операций.

### Оператор присваивания 

Основной оператор присваивания `=` используется для присвоения значений переменным.

```
double x;
x = 50.05;
```

Здесь переменной `x` присваивается значение 50.05.

### Арифметические операторы

Арифметические операторы используются для выполнения арифметических операций: сложение, вычитание, умножение, деление и т. д. 

```
int x = 5;
int y = 10;
int z = x + y; // z = 15
```

| Оператор | Название оператора | Пример | 
|----------|----------|--------|
| `+` | Сложение | `6 + 3` -> `9` |
| `-` | Вычитание | `10 - 6` -> `4` |
| `*` | Умножение | `4 * 2` -> `8` |
| `/` | Деление | `10 / 5` -> `2` |
| `%` | Остаток от деления | `16 % 3` -> `1` |

Пример:
```
using System;
 
namespace Operator
{
    class ArithmeticOperator
    {
        public static void Main(string[] args)
        {
            double firstNumber = 14.40, secondNumber = 4.60, result;
            int num1 = 26, num2 = 4, rem;

            // Оператор сложения
            result = firstNumber + secondNumber;
            Console.WriteLine("{0} + {1} = {2}", firstNumber, secondNumber, result);

            // Оператор вычитания
            result = firstNumber - secondNumber;
            Console.WriteLine("{0} - {1} = {2}", firstNumber, secondNumber, result)

            // Оператор умножения
            result = firstNumber * secondNumber;
            Console.WriteLine("{0} * {1} = {2}", firstNumber, secondNumber, result);

            // Оператор деления
            result = firstNumber / secondNumber;
            Console.WriteLine("{0} / {1} = {2}", firstNumber, secondNumber, result);

            // Оператор взятия остатка
            rem = num1 % num2;
            Console.WriteLine("{0} % {1} = {2}", num1, num2, rem);
        }
    }
}
```

Вывод:
```
14.4 + 4.6 = 19
14.4 - 4.6 = 9.8
14.4 * 4.6 = 66.24
14.4 / 4.6 = 3.1304347826087
26 % 4 = 2
```

### Операторы сравнения

Операторы сравнения (они же — операторы отношения) используются для проверки связи между двумя операндами. Если сравнение истинно, результат будет `true`, иначе — `false`. Операторы отношения обычно используются в условиях и циклах.

| Оператор | Название оператора | Пример | 
|----------|----------|--------|
| `==` | Равно | `6 == 4` -> false |
| `>` | Больше | `3 > -1` -> true |
| `<` | Меньше | `5 < 3` -> false |
| `>=` | Больше или равно | `4 >= 4` -> true |
| `<=` | Меньше или равно | `5 <= 3` -> false |
| `!=` | Не равно | `16 != 3` -> true |

Пример:
```
using System;

namespace Operator
{
class RelationalOperator
{
    public static void Main(string[] args)
    {
        bool result;
        int firstNumber = 10, secondNumber = 20;

        result = (firstNumber==secondNumber);
        Console.WriteLine("{0} == {1} возвращает {2}",firstNumber, secondNumber, result);

        result = (firstNumber > secondNumber);
        Console.WriteLine("{0} > {1} возвращает {2}",firstNumber, secondNumber, result);

        result = (firstNumber < secondNumber);
        Console.WriteLine("{0} < {1} возвращает {2}",firstNumber, secondNumber, result);

        result = (firstNumber >= secondNumber);
        Console.WriteLine("{0} >= {1} возвращает {2}",firstNumber, secondNumber, result);

        result = (firstNumber <= secondNumber);
        Console.WriteLine("{0} <= {1} возвращает {2}",firstNumber, secondNumber, result);

        result = (firstNumber != secondNumber);
        Console.WriteLine("{0} != {1} возвращает {2}",firstNumber, secondNumber, result);
    }
}
}
```

Вывод:
```
10 == 20 возвращает False
10 > 20 возвращает False
10 < 20 возвращает True
10 >= 20 возвращает False
10 <= 20 возвращает True
10 != 20 возвращает True
```

### Логические операторы

Логические операторы используются для выполнения таких логических операций, как `AND` (ИЛИ), `OR` (И) и т. д. Логические операторы работают с булевыми выражениями и возвращают булевые значения `true` и `false`. Логические операторы нужны для принятия решений и в циклах.


| Операнд 1 | Операнд 2 | OR (`\|\|`) | AND (`&&`) |
|:---------:|:---------:|:-----------:|:----------:|
| `true`    | `true`    | `true`      | `true`     |
| `true`    | `false`   | `true`      | `false`    |
| `false`   | `true`    | `true`      | `false`    |
| `false`   | `false`   | `false`     | `false`    |

Проще говоря:

- Если один из операндов `true`, то `OR` вернет `true`.
- Если один из операндов равен `false`, оператор `AND` вернет `false`.

Пример:
```
using System;
 
namespace Operator
{
    class LogicalOperator
    {
        public static void Main(string[] args)
        {
            bool result;
            int firstNumber = 10, secondNumber = 20;

            // оператор ИЛИ
            result = (firstNumber == secondNumber) || (firstNumber > 5);
            Console.WriteLine(result);

            // оператор И
            result = (firstNumber == secondNumber) && (firstNumber > 5);
            Console.WriteLine(result);
        }
    }
}
```

Вывод:
```
True
False
```

### Унарные операторы

Унарные операторы работают только с одним операндом — это отличает их от всех остальных операторов.

| Оператор | Название оператора | Описание | 
|----------|----------|--------|
| `+` | Унарный плюс | Оставляет знак операнда таким же |
| `-` | Унарный минус | Меняет знак операнда |
| `++` | Инкремент | Увеличивает значение операнда на 1 |
| `--` | Декремент | Уменьшает значение операнда на 1 |
| `!` | Логическое отрицание | Инвертирует логическое значение операнда |

Пример:
```
using System;
 
namespace Operator
{
    class UnaryOperator
    {
        public static void Main(string[] args)
        {
            int number = 10, result;
            bool flag = true;

            result = +number;
            Console.WriteLine("+number = " + result);

            result = -number;
            Console.WriteLine("-number = " + result);

            result = ++number;
            Console.WriteLine("++number = " + result);

            result = --number;
            Console.WriteLine("--number = " + result);

            Console.WriteLine("!flag = " + (!flag));
        }
    }
}
```

Вывод:
```
+number = 10
-number = -10
++number = 11
--number = 10
!flag = False
```

Операторы инкремента `++` и декремента `--` могут использоваться как префикс и постфикс. Если использовать их как префикс, изменение значения переменной отображается в той же строке, а если как постфикс, изменение значения переменной отображается в следующей строке.

Пример:
```
using System;
 
namespace Operator
{
    class UnaryOperator
    {
        public static void Main(string[] args)
        {
            int number = 10;

            Console.WriteLine((number++));
            Console.WriteLine((number));

            Console.WriteLine((++number));
            Console.WriteLine((number));
        }
    }
}
```

Вывод:
```
10
11
12
12
```

Когда `++` используется после операнда, значение сначала оценивается, а затем увеличивается на 1. Следовательно, оператор `Console.WriteLine((number++));` выводит 10 вместо 11. После того, как значение выведено, оно увеличивается на 1.

Если `++` используется в качестве префикса, процесс обратный. Значение сначала увеличивается, а затем выводится. Следовательно, выражение `Console.WriteLine((++number));` выводит 12.

То же самое и с оператором декремента `--`.

### Тернарный оператор

Тернарный оператор `?` `:` работает с тремя операндами. Это сокращение для конструкции `if-then-else`. Тернарный оператор можно использовать следующим образом:

```
переменная = условие? выражение1: выражение2;
```

Тернарный оператор работает вот так: 

- Если выражение, указанное в условии равно `true`, переменной присваивается результат выражения1.
- Если же выражение равно `false`, переменной присваивается результат выражения2.

### Побитовые операторы

Побитовые операторы и операторы побитового сдвига используются для выполнения манипуляций с битами.

| Оператор | Название оператора |
|----------|----------|
| `~` |  Побитовое отрицание | 
| `&` | Побитовое И |
| `\|` | Побитовое ИЛИ | 
| `^` | Побитовое исключающее ИЛИ |
| `<<` | Побитовый сдвиг влево |
| `>>` | Побитовый сдвиг вправо |

Пример:
```
using System;
 
namespace Operator
{
    class BitOperator
    {
        public static void Main(string[] args)
        {
            int firstNumber = 10;
            int secondNumber = 20;
            int result;

            result = ~firstNumber;
            Console.WriteLine("~{0} = {1}", firstNumber, result);

            result = firstNumber & secondNumber;
            Console.WriteLine("{0} & {1} = {2}", firstNumber,secondNumber, result);

            result = firstNumber | secondNumber;
            Console.WriteLine("{0} | {1} = {2}", firstNumber,secondNumber, result);

            result = firstNumber ^ secondNumber;
            Console.WriteLine("{0} ^ {1} = {2}", firstNumber,secondNumber, result);

            result = firstNumber << 2;
            Console.WriteLine("{0} << 2 = {1}", firstNumber, result);

            result = firstNumber >> 2;
            Console.WriteLine("{0} >> 2 = {1}", firstNumber, result);
        }
    }
}
```

Вывод:
```
~10 = -11
10 & 20 = 0
10 | 20 = 30
10 ^ 20 = 30
10 << 2 = 40
10 >> 2 = 2
```

### Составные операторы присваивания

| Оператор | Название оператора | Пример | Эквивалентно |
|:---------:|:---------:|:-----------:|:----------:|
| `+=`    | Оператор сложения и присваивания | `x += 5`      | `x = x + 5`     |
| `-=`    | Оператор вычитания и присваивания   | `x -= 5`      | `x = x - 5`    |
| `*=`   | Оператор умножения и присваивания    | `x *= 5`      | `x = x * 5`    |
| `/=`   | Оператор деления и присваивания   | `x /= 5`     | `x = x / 5`    |
| `%=`   | Оператор присваивания остатка  | `x %= 5`     | `x = x % 5`    |
| `&=`   |	Оператор побитового И и присваивания  | `x &= 5`     | `x = x & 5`    |
| `\|=`   |Оператор побитового ИЛИ и присваивания  | `x \|= 5`     | `x = x \| 5`    |
| `^=`   |	Оператор исключающего ИЛИ и присваивания| `x ^= 5`     | `x = x ^ 5`    |
| `<<=`   |Оператор побитового сдвига влево и присваивания  | `x <<= 5`     | `x = x << 5`    |
| `>>=`   | 	Оператор побитового сдвига вправо и присваивания  | `x >>= 5`     | `x = x >> 5`    |
| `=>`   | Лямбда-оператор  |`x => x*x`    | Возвращает `x * x`   |

## 6. Прочие лексемы

**Разделители:**
- Точка с запятой `;` - объявляет конец инструкции или выражения.
- 
- Запятая `,` — разделяет элементы в списках параметров, аргументов, инициализаторов.

- Точка `.` — доступ к членам объекта или пространства имен.

- Двоеточие `:` — используется в объявлении наследования и наименовании меток.

- Двойное двоеточие `::` — используется редко, например для указания глобального пространства имен.

**Скобки**
- Круглые скобки `(` и `)` — группировка выражений, вызовы методов, объявление параметров.

- Фигурные скобки `{` и `}` — блоки кода, тела методов, классов, структур.

- Квадратные скобки `[` и `]` — атрибуты, индексация массивов, создание массивов.

**Другие лексемы**

- Вопросительный знак `?` — обозначает **nullable** типы или используется в тернарном операторе, операторе **null**-объединения.

- Символ `@` — используется перед идентификаторами для экранирования ключевых слов или в строках (verbatim string).

## Комментарии

В C# используются два основных типа синтаксиса для обозначения комментариев: однострочные комментарии начинаются с `//` и заканчиваются с переходом на новую строку, а многострочные комментарии начинаются с `/*` и заканчиваются с `*/`. Кроме того, есть XML-комментарии, которые начинаются с `///` и используются для автоматической генерации документации. 

Примеры:
1. Однострочный комментарий:
```
// Это однострочный комментарий
int x = 10; // Присваиваем значение 10
```

2. Многострочный комментарий:
```
/*
Это многострочный
комментарий,
который может занимать
несколько строк [1].
*/
```

3. XML- комментарии:
```
/// <summary>
/// Этот метод вычисляет сумму двух чисел.
/// </summary>
/// <param name="a">Первое число.</param>
/// <param name="b">Второе число.</param>
/// <returns>Сумма a и b.</returns>
public int Add(int a, int b)
{
    return a + b;
}
```
