# Спецификация верхнего уровня грамматики языка StarLight

## Пример кода

```
ЗВЕЗДА
    КОНСТЕЛЛАЦИЯ пи : нова = 3.14159;
    СВЕТ x : нова = 3.0;
    СВЕТ y : нова = 4.0;
    СВЕТ расстояние : нова;
    
    ФОТОН вычислить_расстояние(a: нова, b: нова) : нова {
    ВЕРНУТЬ sqrt((a - x)**2 + (b - y)**2);
}

ФОТОН процесс_вывода() : вакуум {
    ПРИЕМ_СИГНАЛА(расстояние);
    расстояние = вычислить_расстояние(x, y);
    
    ЕСЛИ (расстояние > 5.0) {
        ИЗЛУЧАТЬ("Далеко: " + расстояние);
        СПЕКТР (i = 0; i < 3; i += 1) {
            ЕСЛИ (i == 1) {
                ПРОДОЛЖИТЬ;
            }
            ИЗЛУЧАТЬ("Итерация " + i);
            ЕСЛИ (i == 2) {
                ПРЕРВАТЬ;
            }
        }
    } ИЛИ_НЕТ ЕСЛИ (расстояние < 2.0) {
        ИЗЛУЧАТЬ("Близко: " + расстояние);
    } ИЛИ_НЕТ {
        ОРБИТА (расстояние < 10.0) {
            расстояние *= пи;
            ИЗЛУЧАТЬ("Умножено на пи: " + расстояние);
            ЕСЛИ (расстояние > 15.0) {
                ПРЕРВАТЬ;
            }
        }
    }
}

процесс_вывода();

ЗАКРЫТАЯ_ЗВЕЗДА
```

## Ключевые особенности языка

StarLight - процедурный язык программирования со статической типизацией, вдохновленный космической тематикой. Основные особенности:

**Структура программы**

Программа заключается в блок `ЗВЕЗДА...ЗАКРЫТАЯ ЗВЕЗДА`. Инструкции выполняются последовательно. Блоки кода (в условных операторах, циклах, функциях) определяются отступами (4 пробела или 1 табуляция).

**Область действия**

StarLight использует блочную область видимости.

1. Глобальная область видимости:
   - Переменные и константы, объявленные на верхнем уровне программы (вне функций и блоков)

   - Видны во всей программе, включая все функции и блоки

2. Область видимости функции:
   - Параметры функции и переменные, объявленные в теле функции
  
   - Видны только внутри этой функции
  
   - Скрывают глобальные переменные с тем же именем

3. Блочная область видимости:
   - Переменные, объявленные внутри блоков (в if, while, for, и произвольных блоках)
  
   - Видны только внутри блока, где объявлены, и во вложенных блоках
  
   - Уничтожаются при выходе из блока

**Переменные и константы**

В StarLight поддерживаются как изменяемые (mutable) переменные, так и неизменяемые (immutable) константы. Это позволяет разработчикам явно контролировать мутабельность данных: переменные можно изменять после объявления (через присваивания), а константы — нет, что предотвращает случайные ошибки и повышает безопасность кода. Объявления требуют явного указания типа (статическая типизация), имена уникальны в пределах области видимости (scope). Доступ к необъявленной переменной или константе — ошибка компиляции. Повторное объявление с тем же именем в одной области видимости запрещено (ошибка). Области видимости — блочные (функции, циклы, условия), с наследованием от внешних блоков (внутренние видят внешние, но не переопределяют их).

Синтаксис объявлений:
- Объявление переменной (mutable): Ключевое слово `СВЕТ`.
  
  Пример:
  ```СВЕТ счетчик : квазар = 0;```

- Объявление константы (immutable): Ключевое слово `КОНСТЕЛЛАЦИЯ`.  Инициализация обязательна — константа должна быть определена сразу.
  
  Пример:
  `КОНСТЕЛЛАЦИЯ гравитация : нова = 9.81;`

**Ввод/вывод**

Ввод-вывод реализован с помощью инструкций с ключевыми словами, что обеспечивает простоту и читаемость кода без необходимости импорта модулей. 
- *Ввод* (`ПРИЕМ_СИГНАЛА`): Читает значение из стандартного ввода и присваивает значение указанной переменной. 
  
    Синтаксис: `ПРИЕМ_СИГНАЛА (имя_переменной);`

    Пример:
    ```
    СВЕТ число : квазар;
    ПРИЕМ_СИГНАЛА(число);
    ```

- *Вывод* (`ИЗЛУЧАТЬ`): Выводит значение выражения (или несколько через запятые) в стандартный вывод (stdout).
 
    Синтаксис: `ИЗЛУЧАТЬ(<выражение> [, <выражение> ...]);`

    Пример:
    ```
    СВЕТ x : квазар = 42;
    ИЗЛУЧАТЬ("Значение x:", x, "квадрат:", x * x);
    ```

**Виды инструкций**

Инструкции (statements) спроектированы как императивные конструкции с побочными эффектами, чтобы избежать бесполезных вычислений без сохранения результата или изменения состояния. Грамматика намеренно ограничивает правило `"statement = expression;"`, заменяя его на явный список разрешенных видов. Это обеспечивает читаемость и предотвращает ошибки (например, `x + 10`; запрещено, так как результат никуда не сохраняется). Любое выражение может быть частью инструкции (в присваивании или вызове), но само по себе — нет.

Разрешенные виды инструкций:

Инструкции выполняются последовательно в блоках (глобальном или вложенном). Основные виды:

|Вид инструкции| Ключевое слово| Пример |
|--------------|---------------|--------|
|Объявление переменной|`СВЕТ id : type [= expr];`|`СВЕТ x : квазар = 10;`|
|Объявление константы|`КОНСТЕЛЛАЦИЯ id : type = expr;`|`КОНСТЕЛЛАЦИЯ e : нова = 2.718;`|
|Присваивание|`id op= expr;` (op: =, +=, -=, *=, /=, **=)|`x += 5;`|
|Вызов/IO|`ИЗЛУЧАТЬ(expr);`|`ИЗЛУЧАТЬ("Привет");`|
|If-else|`ЕСЛИ (expr) { block } [ИЛИ_НЕТ { block }];`|`ЕСЛИ (x > 0) { ... }`|
|while|`ОРБИТА (expr) { block };`|`ОРБИТА (i < 10) { ... }`|
|for|`СПЕКТР (init; cond; update) { block };`|`СПЕКТР (i=0; i<5; i+=1) { ... }`|
|return|`ВЕРНУТЬ [expr];`|`ВЕРНУТЬ x * 2;`|
|функция|`ФОТОН id(params) : type { block };`|`ФОТОН сумма(a, b) : квазар { ... }`|

Чистые expr запрещены; все statements с `;`.

**Ветвелния и циклы**

Ветвление (if-else): Условный оператор `ЕСЛИ` выполняет блок кода, если выражение в скобках оценивается как истинно (тип `вакуум` = ИСТИНА).

Опциональный блок `ИЛИ_НЕТ` выполняется, если условие ложно. Блоки определяются отстпами. Для разрешения проблемы висячего else (dangling else) : `ИЛИ_НЕТ` присоединяется к ближайшему предыдущему `ЕСЛИ` без своего `ИЛИ_НЕТ` (стандартное правило ассоциации к ближайшему if, как в Python).
Пустые блоки разрешены.

Цикл **while** (ОРБИТА) : Цикл `ОРБИТА` проверяет условие (тип `вакуум`) перед каждой итерацией. Если истино, выполняется болк, иначе - выход.
Бесконечный цикл возможен при постоянном истинном условии.

Цикл **for** (СПЕКТР): Цикл ёСПЕКТРё инициализирует переменную (сокращенное объявление `id: type = expr` или присваивание/выражение), проверяет условие, выполняет блок, обновляет (присваивание/выражение), и повторяет. Инициализация и обновление опциональны. Объявление в init создает блочную переменную, видимую в цикле. Условие по умолчанию истинно, если опущено.

**Пользовательские функции**

Определение функций (ФОТОН): Функции объявляются ключевым словом `ФОТОН`, с именем, списком параметров (каждый с типом, опционально), возвращаемым типом (опционально, по умолчанию `вакуум` для процедур). Тело — блок с отступами. Функции могут быть рекурсивными (включая взаимную рекурсию: функции видны после объявления в области). Параметры — локальные, immutable по умолчанию ( shadowing globals). Возврат значения через `ВЕРНУТЬ expr;` (без expr — `вакуум`). Процедуры (без возврата) — подмножество функций с типом `вакуум`. Функции без параметров разрешены. Аргументы вычисляются слева направо.

**Разделитель инструкций**

Инструкции разделяются `;` (обязательно в конце, кроме блоков). Переносы строк игнорируются, кроме отступов для блоков (4 пробела/1 таб). Без `;` — ошибка. Отступы определяют вложенность (как Python). Это упрощает парсинг; для ошибок — игнор до `;`, отчет о всех.

## Семантические правила

- Запрет на повторное объявление переменных или констант с тем же именем в одной области видимости — ошибка компиляции.
  
- Константы неизменяемы: любое присваивание после инициализации — ошибка компиляции.

- Статическая типизация: проверка типов в выражениях, присваиваниях и вызовах; несовместимые операции (e.g., сложение строки и числа без приведения) — ошибка компиляции. Автоматическое приведение только в безопасных случаях (e.g., квазар → нова).

- Области видимости: блочные, с shadowing (внутренние переменные скрывают внешние с тем же именем); глобальные объявления видимы во всей программе.
 
- Ввод-вывод: `ПРИЕМ_СИГНАЛА` парсит ввод по типу переменной (runtime-ошибка при несоответствии, e.g., строка вместо числа); `ИЗЛУЧАТЬ` автоматически приводит не-строки к строкам для конкатенации.
  
- Инструкции: Условия в `ЕСЛИ`, `ОРБИТА`, `СПЕКТР` требуют типа `вакуум (bool)`; пустые блоки разрешены, но бесполезны. Рекурсия в функциях разрешена.
  
- Функции: Возврат без выражения возвращает `вакуум` (ЛОЖЬ по умолчанию); параметры — локальные, с проверкой типов.

- Ветвления: Условия в `ЕСЛИ` должны иметь тип `вакуум`. Поддерживаются цепочки `ИЛИ_НЕТ ЕСЛИ`.

- Циклы: Условия в `ОРБИТА` и `СПЕКТР` должны иметь тип `вакуум`.
- **Break/Continue**: `ПРЕРВАТЬ` и `ПРОДОЛЖИТЬ` могут использоваться только внутри циклов.

- Функции: Рекурсия и взаимная рекурсия разрешены. Параметры передаются по значению.
  
- Область видимости: Каждый блок создает новую область видимости. Функции могут обращаться к переменным из внешних областей.

## Проверка на левую рекурсию и факторизацию

### Проверка грамматики выражений:
**Левая рекурсия**: Отсутствует - все бинарные операторы используют правую рекурсию(e.g., `power = unary [ "**" power ]`), или итеративные левые без прямой рекурсии (e.g., `additive = multiplicative { "+" multiplicative }`). Unary не рекурсивен на себя.

**Левая факторизация**: Реализована через явное разделение альтернатив. 

### Проверка грамматики верхнего уровня:
**Проблема висячего else**: Решена через явное определение цепочек ИЛИ_НЕТ ЕСЛИ

**Левая факторизация**: Function_call и function_call_expression разделены по контексту

## Ключевые улучшения:
- **Ветвления:** Поддержка цепочек `ИЛИ_НЕТ ЕСЛИ` с решением проблемы висячего else

- **Циклы:** Полная поддержка `СПЕКТР` (for) и `ОРБИТА` (while)

- **Функции:** Объявление и вызов пользовательских функций с параметрами и возвращаемыми значениями

- **Управление потоком:** `ПРЕРВАТЬ`, `ПРОДОЛЖИТЬ`, `ВЕРНУТЬ`

## Грамматика в нотации EBNF

**Основная конструкция программы**
```
program = "ЗВЕЗДА", { statement }, "ЗАКРЫТАЯ ЗВЕЗДА" ;

block = "{", { statement }, "}" ;

statement = variable_declaration 
            | constant_declaration
            | assignment 
            | print_statement
            | input_statement
            | function_call 
            | if_statement 
            | while_statement 
            | for_statement 
            | function_declaration
            | return_statement
            | break_statement
            | continue_statement ;
```

**Объявления**
```
variable_declaration = "СВЕТ", identifier, ":", type, [ "=", expression ], ";" ;

constant_declaration = "КОНСТЕЛЛАЦИЯ", identifier, ":", type, "=", expression, ";" ;

function_declaration = "ФОТОН", identifier, "(", [ parameter_list ], ")", [ ":", type ], block ;

parameter_list = parameter, { ",", parameter } ;

parameter = identifier, ":", type ;
```

**Инструкции**
```
assignment = identifier, assignment_op, expression, ";" ;
assignment_op = "=" | "+=" | "-=" | "*=" | "/=" | "**=" ;

print_statement = "ИЗЛУЧАТЬ", "(", [ argument_list ], ")", ";" ;

input_statement = "ПРИЕМ_СИГНАЛА", "(", identifier, ")", ";" ;

function_call = ( "ИЗЛУЧАТЬ" | "ПРИЕМ_СИГНАЛА" | identifier ), "(", [ argument_list ], ")", ";" ;

argument_list = expression, { ",", expression } ;

if_statement = "ЕСЛИ", "(", expression, ")", block,
{ "ИЛИ_НЕТ", "ЕСЛИ", "(", expression, ")", block },
[ "ИЛИ_НЕТ", block ] ;

while_statement = "ОРБИТА", "(", expression, ")", block ;

for_statement = "СПЕКТР", "(", [ for_init ], ";", [ expression ], ";", [ for_update ], ")", block ;
for_init = variable_declaration | assignment | expression | ";" ;
for_update = assignment | function_call | expression | ";" ;

return_statement = "ВЕРНУТЬ", [ expression ], ";" ;

break_statement = "ПРЕРВАТЬ", ";" ;

continue_statement = "ПРОДОЛЖИТЬ", ";" ;

type = "квазар" | "нова" | "вакуум" | "галактика" ;

(* Выражения: см. docs/specification/expressions-grammar.md *)
(* expression = [определение из expressions-grammar.md] *)

(* Идентификатор: см. docs/specification/lexical-structure.md *)
(* identifier = [определение из lexical-structure.md] *)
```

