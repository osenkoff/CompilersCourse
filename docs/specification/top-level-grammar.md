# Спецификация верхнего уровня грамматики языка StarLight

## Пример кода

```
ЗВЕЗДА
    КОНСТЕЛЛАЦИЯ пи : нова = 3.14159;
    СВЕТ x : нова = 3.0;
    СВЕТ y : нова = 4.0;
    СВЕТ расстояние : нова;
    
    ФОТОН вычислить_расстояние(a: нова, b: нова) : нова {
        ВЕРНУТЬ sqrt((a - x)**2 + (b - y)**2);
    }
    
    ПРИЕМ_СИГНАЛА(расстояние);
    расстояние = вычислить_расстояние(x, y);
    
    ЕСЛИ (расстояние > 5.0) {
        ИЗЛУЧАТЬ("Далеко: " + расстояние);
        СПЕКТР (i: квазар = 0; i < 3; i += 1) {
            ИЗЛУЧАТЬ("Итерация " + i);
        }
    } ИЛИ_НЕТ {
        ОРБИТА (расстояние < 10.0) {
            расстояние *= пи;
            ИЗЛУЧАТЬ("Умножено на пи: " + расстояние);
        }
    }
ЗАКРЫТАЯ_ЗВЕЗДА
```

## Ключевые особенности языка

StarLight - процедурный язык программирования со статической типизацией, вдохновленный космической тематикой. Основные особенности:

**Структура программы**

Программа заключается в блок `ЗВЕЗДА...ЗАКРЫТАЯ ЗВЕЗДА`. Инструкции выполняются последовательно. Блоки кода (в условных операторах, циклах, функциях) определяются отступами (4 пробела или 1 табуляция).

**Область действия**

StaLight использует блочную область видимости.

1. Глобальная область видимости:
   - Переменные и константы, объявленные на верхнем уровне программы (вне функций и блоков)

   - Видны во всей программе, включая все функции и блоки

2. Область видимости функции:
   - Параметры функции и переменные, объявленные в теле функции
  
   - Видны только внутри этой функции
  
   - Скрывают глобальные переменные с тем же именем

3. Блочная область видимости:
   - Переменные, объявленные внутри блоков {} (в if, while, for, и произвольных блоках)
  
   - Видны только внутри блока, где объявлены, и во вложенных блоках
  
   - Уничтожаются при выходе из блока

**Переменные и константы**

В StarLight поддерживаются как изменяемые (mutable) переменные, так и неизменяемые (immutable) константы. Это позволяет разработчикам явно контролировать мутабельность данных: переменные можно изменять после объявления (через присваивания), а константы — нет, что предотвращает случайные ошибки и повышает безопасность кода. Объявления требуют явного указания типа (статическая типизация), имена уникальны в пределах области видимости (scope). Доступ к необъявленной переменной или константе — ошибка компиляции. Повторное объявление с тем же именем в одной области видимости запрещено (ошибка). Области видимости — блочные (функции, циклы, условия), с наследованием от внешних блоков (внутренние видят внешние, но не переопределяют их).

Синтаксис объявлений:
- Объявление переменной (mutable): Ключевое слово `СВЕТ`.
  
  Пример:
  ```СВЕТ счетчик : квазар = 0;```

- Объявление константы (immutable): Ключевое слово `КОНСТЕЛЛАЦИЯ`.  Инициализация обязательна — константа должна быть определена сразу.
  
  Пример:
  `КОНСТЕЛЛАЦИЯ гравитация : нова = 9.81;`

**Ввод/вывод**

Ввод-вывод реализован с помощью инструкций с ключевыми словами, что обеспечивает простоту и читаемость кода без необходимости импорта модулей. 
- *Ввод* (`ПРИЕМ_СИГНАЛА`): Читает значение из стандартного ввода и присваивает значение указанной переменной. 
  
    Синтаксис: `ПРИЕМ_СИГНАЛА (имя_переменной);`

    Пример:
    ```
    СВЕТ число : квазар;
    ПРИЕМ_СИГНАЛА(число);
    ```

- *Вывод* (`ИЗЛУЧАТЬ`): Выводит значение выражения (или несколько через запятые) в стандартный вывод (stdout).
 
    Синтаксис: `ИЗЛУЧАТЬ(<выражение> [, <выражение> ...]);`

    Пример:
    ```
    СВЕТ x : квазар = 42;
    ИЗЛУЧАТЬ("Значение x:", x, "квадрат:", x * x);
    ```

**Виды инструкций**

Инструкции (statements) спроектированы как императивные конструкции с побочными эффектами, чтобы избежать бесполезных вычислений без сохранения результата или изменения состояния. Грамматика намеренно ограничивает правило `"statement = expression;"`, заменяя его на явный список разрешенных видов. Это обеспечивает читаемость и предотвращает ошибки (например, `x + 10`; запрещено, так как результат никуда не сохраняется). Любое выражение может быть частью инструкции (в присваивании или вызове), но само по себе — нет.

Разрешенные виды инструкций:

Инструкции выполняются последовательно в блоках (глобальном или вложенном). Основные виды:

|Вид инструкции| Ключевое слово| Пример |
|--------------|---------------|--------|
|Объявление переменной|`СВЕТ id : type [= expr];`|`СВЕТ x : квазар = 10;`|
|Объявление константы|`КОНСТЕЛЛАЦИЯ id : type = expr;`|`КОНСТЕЛЛАЦИЯ e : нова = 2.718;`|
|Присваивание|`id op= expr;` (op: =, +=, -=, *=, /=, **=)|`x += 5;`|
|Вызов/IO|`ИЗЛУЧАТЬ(expr);`|`ИЗЛУЧАТЬ("Привет");`|
|If-else|`ЕСЛИ (expr) { block } [ИЛИ_НЕТ { block }];`|`ЕСЛИ (x > 0) { ... }`|
|while|`ОРБИТА (expr) { block };`|`ОРБИТА (i < 10) { ... }`|
|for|`СПЕКТР (init; cond; update) { block };`|`СПЕКТР (i=0; i<5; i+=1) { ... }`|
|return|`ВЕРНУТЬ [expr];`|`ВЕРНУТЬ x * 2;`|
|функция|`ФОТОН id(params) : type { block };`|`ФОТОН сумма(a, b) : квазар { ... }`|

Чистые expr запрещены; все statements с `;`.

**Разделитель инструкций**

Инструкции разделяются `;` (обязательно в конце, кроме блоков). Переносы строк игнорируются, кроме отступов для блоков (4 пробела/1 таб). Без `;` — ошибка. Отступы определяют вложенность (как Python). Это упрощает парсинг; для ошибок — игнор до `;`, отчет о всех.

## Семантические правила

- Запрет на повторное объявление переменных или констант с тем же именем в одной области видимости — ошибка компиляции.
  
- Константы неизменяемы: любое присваивание после инициализации — ошибка компиляции.

- Статическая типизация: проверка типов в выражениях, присваиваниях и вызовах; несовместимые операции (e.g., сложение строки и числа без приведения) — ошибка компиляции. Автоматическое приведение только в безопасных случаях (e.g., квазар → нова).

- Области видимости: блочные, с shadowing (внутренние переменные скрывают внешние с тем же именем); глобальные объявления видимы во всей программе.
 
- Ввод-вывод: `ПРИЕМ_СИГНАЛА` парсит ввод по типу переменной (runtime-ошибка при несоответствии, e.g., строка вместо числа); `ИЗЛУЧАТЬ` автоматически приводит не-строки к строкам для конкатенации.
  
- Инструкции: Условия в `ЕСЛИ`, `ОРБИТА`, `СПЕКТР` требуют типа `вакуум (bool)`; пустые блоки разрешены, но бесполезны. Рекурсия в функциях разрешена.
  
- Функции: Возврат без выражения возвращает `вакуум` (ЛОЖЬ по умолчанию); параметры — локальные, с проверкой типов.

## Грамматика в нотации EBNF

**Основная конструкция программы**
```
program = "ЗВЕЗДА", { statement }, "ЗАКРЫТАЯ ЗВЕЗДА" ;

block = "{", { statement }, "}" ;

statement = variable_declaration 
            | constant_declaration
            | assignment 
            | function_call 
            | if_statement 
            | while_statement 
            | for_statement 
            | function_declaration
            | return_statement ;
```

**Объявления**
```
variable_declaration = "СВЕТ", identifier, ":", type, [ "=", expression ], ";" ;

constant_declaration = "КОНСТЕЛЛАЦИЯ", identifier, ":", type, "=", expression, ";" ;

function_declaration = "ФОТОН", identifier, "(", [ parameter_list ], ")", [ ":", type ], block ;

parameter_list = parameter, { ",", parameter } ;

parameter = identifier, ":", type ;
```

**Инструкции**
```
assignment = identifier, assignment_op, expression, ";" ;
assignment_op = "=" | "+=" | "-=" | "*=" | "/=" | "**=" ;

function_call = ( "ИЗЛУЧАТЬ" | "ПРИЕМ_СИГНАЛА" | identifier ), "(", [ argument_list ], ")", ";" ;

argument_list = expression, { ",", expression } ;

if_statement = "ЕСЛИ", "(", expression, ")", block, [ "ИЛИ_НЕТ", block ] ;

while_statement = "ОРБИТА", "(", expression, ")", block ;

for_statement = "СПЕКТР", "(", [ for_init ], ";", [ expression ], ";", [ for_update ], ")", block ;
for_init = variable_declaration | assignment | expression | ";" ;
for_update = assignment | function_call | expression | ";" ;

return_statement = "ВЕРНУТЬ", [ expression ], ";" ;

type = "квазар" | "нова" | "луч" | "вакуум" | "галактика" ;

(* Выражения: см. docs/specification/expressions-grammar.md *)
(* expression = [определение из expressions-grammar.md] *)

(* Идентификатор: см. docs/specification/lexical-structure.md *)
(* identifier = [определение из lexical-structure.md] *)
```

