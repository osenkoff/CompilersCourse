# Спецификация семантики типов данных языка StarLight

**Типы данных StarLight:**

- **квазар** - целочисленный тип (64-битный, как int в C#). Диапазон: -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807. 

- **нова** - числа с плавающей точкой (IEEE 754 binary64, как double в C#). 

- **вакуум** - булев тип (как bool в C#). Два значения: `ИСТИНА` и `ЛОЖЬ`.

- **галактика** - строковый тип (UTF-8, как string в C#). Поддерживают все символы Unicode. Строки неизменяемы (immutable).

Также поддерживается пустой тип для функций без возвращаемого значения.

## Литералы

### квазар (целые числа)
- Десятичные литералы: `0`, `42`, `-100`, `123456789`
- Шестнадцатеричные литералы: `0xFF`, `0x1A3`
- Бинарные литералы: `0b1010`, `0b1111`
- Восьмеричные литералы: `0o755`, `0o777`

### нова (числа с плавающей точкой)
- Простая форма: `3.14`, `0.5`, `-2.718`
- Научная нотация: `1.5e10`, `2.3E-5`, `6.022e23`

### вакуум (логический тип)
- `ИСТИНА` - истинное значение
- `ЛОЖЬ` - ложное значение

### галактика (строки)
- Строковые литералы в двойных кавычках: `"Привет, мир!"`
- Строковые литералы в одинарных кавычках: `'Звездный свет'`
- Экранирование символов:
  - `\n` - новая строка
  - `\t` - табуляция
  - `\"` - двойная кавычка
  - `\'` - одинарная кавычка
  - `\\` - обратная косая черта
  - `\uXXXX` - символ Unicode (4 шестнадцатеричные цифры)

## Операторы

### Арифметические операторы
- `+`, `-`, `*`, `/`, `%`, `**` - для типов **квазар** и **нова**
- Для целочисленного деления `/` возвращает целую часть
- `%` - остаток от деления (только для **квазар**)

### Операторы сравнения
- `==`, `!=`, `<`, `>`, `<=`, `>=` - для **квазар** и **нова**
- Операторы сравнения возвращают тип **вакуум**

### Логические операторы
- `&&` (И), `||` (ИЛИ), `!` (НЕ) - только для типа **вакуум**
- Логические операторы используют короткую схему вычислений (short-circuit evaluation):
   - Для `a && b`: если `a` ложно, `b` не вычисляется
   - Для `a || b`: если `a` истинно, `b` не вычисляется

### Операторы для строк
- `+` - конкатенация строк
- `==`, `!=` - сравнение строк
- Операторы `<`, `>`, `<=`, `>=` - лексикографическое сравнение

## Переменные

### Объявление переменных
Тип переменной указывается явно при объявлении:
```
СВЕТ число: квазар = 42;
СВЕТ текст: галактика = "Привет";
СВЕТ флаг: вакуум = ИСТИНА;
```

## Константы
Константы объявляются с обязательной инициализацией

```
КОНСТЕЛЛАЦИЯ ПИ: нова = 3.141592653589793;
КОНСТЕЛЛАЦИЯ ПРИВЕТСТВИЕ: галактика = "Добро пожаловать";
```

## Вывод типов 
StarLight использует статическую типизацию с обязательным указанием типа. Вывод типов не поддерживается для обеспечения явности и предотвращения ошибок.

## Изменение типа
Тип переменной не может быть изменен после объявления. Присваивание значения другого типа вызовет ошибку компиляции.

## Преобразования типов

### Неявные преобразования

Разрешены только безопасные неявные преобразования:

- **квазар** -> **нова** (целое в вещественное)
- **квазар** -> **галактика** (при конкатенации или выводе)
- **нова** -> **галактика** (при конкатенации или выводе)
- **вакуум** -> **галактика** (при выводе)

### Явные преобразования

Для явных преобразований используются встроенные функции:

Преобразование в строку:
`строка(значение: любой_тип): галактика`

## Примеры:
```
СВЕТ текст1: галактика = строка(42);  // "42"
СВЕТ текст2: галактика = строка(3.14); // "3.14"
СВЕТ текст3: галактика = строка(ИСТИНА); // "ИСТИНА"
```

Преобразование из строки:
```
в_целое(текст: галактика): квазар
в_вещественное(текст: галактика): нова
в_логическое(текст: галактика): вакуум
```

**Примеры:**
```
СВЕТ число: квазар = в_целое("123");
СВЕТ дробь: нова = в_вещественное("3.14");
СВЕТ флаг: вакуум = в_логическое("ИСТИНА");
```

Преобразование между числовыми типами:
```
целое(значение: нова): квазар  // отбрасывает дробную часть
вещественное(значение: квазар): нова
логическое(значение: квазар): вакуум  // 0 → ЛОЖЬ, остальное → ИСТИНА
```

## Пустой тип

Функции без возвращаемого значения имеют неявный тип `вакуум`:

```
ФОТОН приветствие() {  // Неявный тип возврата: вакуум
    ИЗЛУЧАТЬ("Привет!");
}
```

## Встроенные функции для работы со строками:
**Функция символ()**

```
символ(текст: галактика, индекс: квазар): галактика
```

Назначение: Получить символ из строки по указанному индексу.

Параметры:
- `текст` - строка, из которой нужно извлечь символ
- `индекс` - позиция символа в строке (начинается с 0)
  
Возвращаемое значение: Строка длиной 1 символ (тип `галактика`).

Примеры использования:
```
СВЕТ пример: галактика = "Привет";
СВЕТ первый_символ: галактика = символ(пример, 0);  // "П"
СВЕТ второй_символ: галактика = символ(пример, 1);  // "р"
```

## Примеры программ

1. ToLower - читает строку, переводит все её символы в нижний регистр и печатает результат:
   - Пример: `Hello world!` -> `hello world!`
  
```
ЗВЕЗДА
    ФОТОН в_нижний_регистр(текст: галактика): галактика {
        СВЕТ результат: галактика = "";
        СВЕТ i: квазар = 0;
        
        ОРБИТА (i < длина(текст)) {
            СВЕТ текущий_символ: галактика = символ(текст, i);
            
            ЕСЛИ (текущий_символ == "A") {
                результат = результат + "a";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "B") {
                результат = результат + "b";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "C") {
                результат = результат + "c";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "D") {
                результат = результат + "d";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "E") {
                результат = результат + "e";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "F") {
                результат = результат + "f";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "G") {
                результат = результат + "g";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "H") {
                результат = результат + "h";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "I") {
                результат = результат + "i";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "J") {
                результат = результат + "j";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "K") {
                результат = результат + "k";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "L") {
                результат = результат + "l";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "M") {
                результат = результат + "m";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "N") {
                результат = результат + "n";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "O") {
                результат = результат + "o";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "P") {
                результат = результат + "p";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "Q") {
                результат = результат + "q";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "R") {
                результат = результат + "r";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "S") {
                результат = результат + "s";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "T") {
                результат = результат + "t";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "U") {
                результат = результат + "u";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "V") {
                результат = результат + "v";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "W") {
                результат = результат + "w";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "X") {
                результат = результат + "x";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "Y") {
                результат = результат + "y";
            } ИЛИ_НЕТ ЕСЛИ (текущий_символ == "Z") {
                результат = результат + "z";
            } ИЛИ_НЕТ {
                результат = результат + текущий_символ;
            }
            
            i = i + 1;
        }
        
        ВЕРНУТЬ результат;
    }
    
    СВЕТ вход: галактика;
    ИЗЛУЧАТЬ("Введите текст: ");
    ПРИЕМ_СИГНАЛА(вход);
    
    СВЕТ результат: галактика = в_нижний_регистр(вход);
    ИЗЛУЧАТЬ(результат);
ЗАКРЫТАЯ_ЗВЕЗДА
```

2. CountVowels - читает строку и выводит число гласных букв английского алфавита в этой строке

- Пример: `"Hello world" -> "3"`

```
ЗВЕЗДА
    ФОТОН подсчет_гласных(текст: галактика): квазар {
        СВЕТ счетчик: квазар = 0;
        СВЕТ i: квазар = 0;
        
        ОРБИТА (i < длина(текст)) {
            СВЕТ сим: галактика = символ(текст, i);
  
            ЕСЛИ (сим == "a" || сим == "A" ||
                  сим == "e" || сим == "E" ||
                  сим == "i" || сим == "I" ||
                  сим == "o" || сим == "O" ||
                  сим == "u" || сим == "U") {
                счетчик = счетчик + 1;
            }
            
            i = i + 1;
        }
        
        ВЕРНУТЬ счетчик;
    }
    
    СВЕТ вход: галактика;
    ИЗЛУЧАТЬ("Введите текст: ");
    ПРИЕМ_СИГНАЛА(вход);
    
    СВЕТ количество: квазар = подсчет_гласных(вход);
    ИЗЛУЧАТЬ("Гласных букв: ", количество);
ЗАКРЫТАЯ_ЗВЕЗДА
```

3. IsLeapYear - читает номер года, проверяет, является ли он високосным, печатает "yes" или "no"/
   - Проверять надо согласно григорианскому календарю
   - Пример: "2025" -> "no"
   - Пример: "2024" -> "yes"
   - Пример: "1600" -> "no"
   - Пример: "2000" -> "yes"
  
```
ЗВЕЗДА
    ФОТОН високосный_ли(год: квазар): вакуум {
        ЕСЛИ (год % 400 == 0) {
            ВЕРНУТЬ ИСТИНА;
        }
        
        ЕСЛИ (год % 100 == 0) {
            ВЕРНУТЬ ЛОЖЬ;
        }
        
        ЕСЛИ (год % 4 == 0) {
            ВЕРНУТЬ ИСТИНА;
        }
        
        ВЕРНУТЬ ЛОЖЬ;
    }
    
    СВЕТ год_строка: галактика;
    ИЗЛУЧАТЬ("Введите год: ");
    ПРИЕМ_СИГНАЛА(год_строка);
    
    СВЕТ год: квазар = в_целое(год_строка);
    
    СВЕТ результат: вакуум = високосный_ли(год);
    
    ЕСЛИ (результат == ИСТИНА) {
        ИЗЛУЧАТЬ("yes");
    } ИЛИ_НЕТ {
        ИЗЛУЧАТЬ("no");
    }
ЗАКРЫТАЯ_ЗВЕЗДА
```